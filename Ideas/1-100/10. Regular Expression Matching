Implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") ? false
isMatch("aa","aa") ? true
isMatch("aaa","aa") ? false
isMatch("aa", "a*") ? true
isMatch("aa", ".*") ? true
isMatch("ab", ".*") ? true
isMatch("aab", "c*a*b") ? true

#############################################################################
At first, handle the edge case: when p is empty, then s should be empty. (
reverse is not correct).

There are two major cases: end with * or not.
Case 1:p ends with *, then p at least has length 2. In this case, we need to 
compare the last character in both s and p, if match, then there are two 
possibilities:remove (x* or .*) in p's tail or remove the last char from s's 
tail, either one is OK; if not match, simply remove the last two chars in p.

Case 2: not ends with '*'. This is the simple case, just compare the last digit 
of each string, if match then move on, otherwise return false;

The code is as following:

public class Solution {
    public boolean isMatch(String s, String p) {
        if(p.length()<1) return s.length()<1;
        int m=s.length(), n=p.length();
        if(p.charAt(n-1)=='*'){
            if(m>0 && (s.charAt(m-1)==p.charAt(n-2) || p.charAt(n-2)=='.')){
                return isMatch(s.substring(0,m-1), p) || isMatch(s, p.substring(0,n-2));
            }
            else{
                return isMatch(s,p.substring(0,n-2));
            } 
        }
        else {
            if(m>0 && (s.charAt(m-1)==p.charAt(n-1) || p.charAt(n-1)=='.')){
                return isMatch(s.substring(0,m-1), p.substring(0,n-1));
            }
            else{
                return false;
            }
        }
    }
}  