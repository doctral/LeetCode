Given a singly linked list, determine if it is a palindrome.
Could you do it in O(n) time and O(1) space?

##############################################################
Algorithm:
The initial condition is, if the linked list is empty or just contains only one element, then it is palindrome. 
1. Using a slow pointer and a fast pointer to find the middle element of the Linked List, after that, the slow pointer points to the middle element.
2. Using slow.next as the head node of the second part linked list, and reverse the order of the second part linked list
3. Compare the vals of each element in the first and second part linked list in the order, and if not match, return false. Otherwise, return true.
##############################################################

Java code:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode p1=head;
        ListNode fast=head;
        ListNode slow=head;
        
        if(head==null || head.next==null)
              return true;
        
        while(fast.next!=null && fast.next.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        
        ListNode current=slow.next;
        slow.next=null;
        
        ListNode prev=null;
        ListNode temp=null;
        
        while(current!=null && current.next!=null){
            temp=current.next;
            current.next=prev;
            prev=current;
            current=temp;
        }
        current.next=prev;
        
        while(current!=null){
            if(current.val!=p1.val)
                return false;
            p1=p1.next;
            current=current.next;
        }
        
        
        
        
        return true;
    }
}
